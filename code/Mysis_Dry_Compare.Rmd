---
title: "Mysis_Dry_Compare"
author: "Andrew Ingalls"
date: "1/1/2022"
output: 
  html_document:
    df_print: paged
---
#Mysis vs. Dry Feed Comparison Study


```{r setup, include=FALSE}


library(openxlsx)
library(tidyverse)
library(lsmeans)
library(plotly)
library(outliers)
library(ggridges)
library(viridis)
library(hrbrthemes)
library(ggResidpanel)
library(qqplotr)
library(EnvStats)
library(rstatix)
library(janitor)
library(broom)
library(datarium)
library(ggplot2)
library(ggpubr)
library(gt)
library(extrafont)
```

## Creating Nutrition Chart
```{r Nutrition = "png"}

font_import(paths="../data/")



yProduct <- c("Mysis", "Gemma")
Protein <-c(.119,.57)
Lipid <- c(.023,.15)
Ash <- c(NA,.105)
Fiber <- c(.005,.002)y
Fatty_Acid <- c(.014,.03)
Moisture <- c(.845, NA)

nutrition <- data.frame(Product,Protein,Lipid,Ash,Fiber,Fatty_Acid,Moisture)

nutrition_long<- nutrition %>%
  pivot_longer(.,Protein:Moisture,names_to = "Nutrient", values_to = "Percentage")

ggplot(nutrition_long, aes(x=Nutrient,y=Percentage, fill=Product))+geom_col(position="dodge")

#Create table using grammar of tables package

gt_table <-nutrition %>% gt()
  
#Change column labels
gt_table <- gt_table %>%
  cols_label(
    Product = md("Product"),
    Protein = md("Protein"),
    Lipid  = md("Lipid"),
    Ash =  md("Ash"),
    Fiber = md("Fiber"),
    Fatty_Acid =  md("Fatty Acid"),
    Moisture = md("Moisture")
  )

#create header table
gt_table <- gt_table %>%
  tab_header (
    title = "Nutrition of Mysis Shrimp vs. Skretting Gemma",
    subtitle = "Macronutrient Percentage from Respective Companies"
  )

#format percentage
gt_table <- gt_table %>%
  fmt_percent(
   c(Protein,Lipid,Ash,Fiber,Fatty_Acid,Moisture),
   rows = everything(),
   decimals = 1
  )
#format alignment
gt_table <- gt_table %>%
  cols_align(
    align = "left",
    columns = c("Product")
  ) %>%
  cols_align(
    align = "center",
    columns =  c("Protein","Lipid","Ash","Fiber","Fatty_Acid","Moisture")
  )%>%
  cols_width(
    c("Product","Protein","Lipid","Ash","Fiber","Fatty_Acid","Moisture") ~ px(100)
  ) %>%
  opt_row_striping()

#Adding footnote
gt_table <- gt_table %>%
  tab_footnote(
    footnote = "Data not provided by manufacturer",
    locations = cells_body(
      columns = "Ash",
      rows = is.na(Ash)
    )
  ) %>%
  tab_footnote(
    footnote = "Data not provided by manufacturer",
    locations = cells_body(
      columns = "Moisture",
      rows = is.na(Moisture)
    )
  )

#Text font, coloring, sizing, some borders gt is fun!

gt_table <- gt_table %>%
#title styling
  tab_style(
    style = list(
      cell_text(
        size =px(30),
        weight = "normal",
        align = "left",
        font = "Bloomsbury"
      )
    ),
    locations = list(
      cells_title(groups = "title")
    )
  ) %>%
#subtitle styling
  tab_style(
    style = list(
      cell_text(
        size =px(15),
        align = "left"
      )
    ),
    locations = list(
      cells_title(groups = "subtitle")
    ) 
  ) %>% 
#cell borders
 tab_style(
  style = list(
   cell_text(
    size = px(15)
   ),
   cell_borders(
    sides = c("bottom", "top"),
    color = 'black',
    weight = px(1)
   )
  ),
  locations = list(
   cells_body(gt::everything())
  )
 ) %>%
#Product styling  
tab_style(
  style = list(
   cell_text(
    font = "Bloomsbury", size = px(20), 
    weight = "bold",
    color = "#2f5375")
  ),
  location = list(
   cells_body(columns = c(Product))
  )
 ) 

gtsave(gt_table,"gt_table.png")


```


## Data Cleaning
These data have some unecessary columns, some poorly titled columns, 
as well as some categories that are not standardize over the time of the project. 
This section will be the cleaning stage of the project

```{r Data_Cleaning, include=TRUE}

df_growth<-read.xlsx("../data/Mysis_Pilot.xlsx", 
                     sheet="Exp_1",detectDates=T)
df_survival<-read.xlsx("../data/Mysis_Pilot.xlsx", 
                       sheet="Survival Census (Progress)",detectDates=T)
df_sex_sort <-read.xlsx("../data/Mysis_Pilot.xlsx", 
                        sheet="Sexing",detectDates=T)

head(df_growth)
head(df_survival)
head(df_sex_sort)

summary(df_growth)
summary(df_survival)
summary(df_sex_sort)

#df_Growth Cleanup
#Remove unneeded columns from df_growth such as Time
#Remove 'age' because samples were taken over the course of 3 days, 
#which is why age-category was added
df_growth <- subset(df_growth,select=-c(Time, Age,Possible.Outliers,Condition.Factor))

#rename columns for ease of use
colnames(df_growth) <- c("Date", "Tank", "Age_Category","Feed_Group",
                         "Length_mm","Mass_mg")

#add unique sample ID column for tracking and comparison
df_growth <- df_growth %>%
  add_column(Sample_ID =  seq(1001,1734,1), .before = "Date")


#changes types and create factors where needed
cols <- c("Tank", "Age_Category","Feed_Group")
df_growth[cols] <- lapply(df_growth[cols], factor)

#check
sapply(df_growth,class)

#reorder age and age category factor levels
df_growth$Age_Category <- factor(df_growth$Age_Category, 
                                 levels = c("Three Months", "Five Months",
                                             "Six Months", "Eight Months", 
                                             "Nine Months","Twelve Months"))

#Check for NAs
df_growth[!complete.cases(df_growth),]

#standardize tank location
old_tank_list <-  c("7.C.4","7.C.5","7.C.6","7.C.7","7.C.8","7.C.9",
                    "7.C.10","7.C.11")
old_tank_list_2nd <- c("7.B.3-4","7.C.3-4","7.C.1-2","7.C.5-6","7.C.7-8",
                       "7.C.9-10","7.E.9-10","7.C.11-12")
new_tank_list <-  c("7.E.3-4","7.E.1-2","7.D.7-8","7.E.11-12","7.D.1-2",
                    "7.D.3-4","7.E.9-10","7.D.5-6")

#batch change the tank locations based on the lists above which was the first 
#mass move of tanks (readme.md)
df_growth <- df_growth %>%
  mutate(Tank = recode(Tank, !!!setNames(new_tank_list, old_tank_list)))

#batch change again for the second mass move of tanks(readme.md)
df_growth <- df_growth %>%
  mutate(Tank = recode(Tank, !!!setNames(new_tank_list, old_tank_list_2nd)))

#Check to make sure we only have 8 tank levels
summary(df_growth)
levels(df_growth$Tank)



#Clean up df_survival

#Remove columns that were just interm calculations in excel. Not needed
df_survival <- subset(df_survival,select=-c(Lost,Total,Male,Female,Unknown)) 

#rename columns for consistency
colnames(df_survival) <- c("Date", "Tank","Feed_Group", "Census")

#batch change the tank locations based on the lists above which was the 
#first mass move of tanks (readme.md)
df_survival <- df_survival %>%
  mutate(Tank = recode(Tank, !!!setNames(new_tank_list, old_tank_list)))

#batch change again for the second mass move of tanks(readme.md)
df_survival <- df_survival %>%
  mutate(Tank = recode(Tank, !!!setNames(new_tank_list, old_tank_list_2nd)))

#Change Tank and Group into Factors
df_survival$Tank <- factor(df_survival$Tank) 
df_survival$Feed_Group <- factor(df_survival$Feed_Group)



#Cleanup Sex_sort data

#remove time column
df_sex_sort <- subset(df_sex_sort, select = -Time)

#Factor Tank and Group
df_sex_sort$Tank <- factor(df_sex_sort$Tank)
df_sex_sort$Group <- factor(df_sex_sort$Group)


#Check all changes using head() summary() and levels()
```

## Exploritory Data Analysis for Growth

Here we will focus on our Growth data. Do we see a normal distribution of data?
Is there a correlation between mass and length?
Condition Factor is a method for showing the health of a fish (similar to BMI)
Do we see condition factor change with age? Any other parameters change with age?
What do we see for outliers? Can these be removed or are they true?
What do our residuals look like, can we use linear regression to explain this?
What does the confidence interval look like for both Feed Groups?
Are we seeing any significant difference between the Feed Groups in the variables?


```{r pressure, echo=FALSE}

#histogram for Mass (Right skewed)
ggplot(df_growth, aes(x=Mass_mg))+geom_histogram(aes(y=..density..))+
  geom_vline(aes(xintercept=mean(Mass_mg)), color="blue", linetype="dashed",size=1)+
  geom_density(alpha=0.2,fill="#FF6666")+
  theme_bw()

#histogram for Length (double peak)
ggplot(df_growth, aes(x=Length_mm))+geom_histogram(aes(y=..density..))+
  geom_vline(aes(xintercept=mean(Length_mm)), color="blue", linetype="dashed",size=1)+
  geom_density(alpha=0.2,fill="#FF6666")+
  theme_bw()


#Histogram by Groups

#MASS
ggplot(df_growth, aes(x=Mass_mg, color=Feed_Group))+geom_histogram(aes(y=..density..),fill='white',alpha=0.5)+
  geom_vline(aes(xintercept=mean(Mass_mg)), color="blue", linetype="dashed",size=1)+
  geom_density(alpha=0.2,fill="#FF6666")+
  theme_bw()+scale_color_brewer(palette="Dark2")
#Length
ggplot(df_growth, aes(x=Length_mm, color=Feed_Group))+geom_histogram(aes(y=..density..),fill="white",alpha=0.5)+
  geom_vline(aes(xintercept=mean(Length_mm)), color="blue", linetype="dashed",size=1)+
  geom_density(alpha=0.2,fill="#FF6666")+
  theme_bw()+scale_color_brewer(palette="Dark2")
#Histogram Plot of Mass for Ages and Groups
ggplot(df_growth, aes(x=Mass_mg, color=Feed_Group))+geom_density(alpha=0.2,fill='grey') + 
  facet_wrap(~Age_Category)

#Histogram Plot of Length for Ages and Groups
ggplot(df_growth, aes(x=Length_mm, color=Feed_Group))+geom_density(alpha=0.2,fill='grey') + 
  facet_wrap(~Age_Category)

ggplot(df_growth, aes(x=Length_mm,y=Age_Category, fill=..x..))+
  geom_density_ridges_gradient(scale=3, rel_min_height=0.01)+
  scale_fill_viridis(name="Length_mm",option="C")+
  labs(title='Mass of Surface Morph by Age')+
  theme_ipsum()+
  theme(
    legend.position = 'none',
    panel.spacing = unit(0.1,'lines'),
    strip.text.x = element_text(size=8)
  ) +
  facet_wrap(~Feed_Group,ncol=1)

ggplot(df_growth, aes(x=Mass_mg,y=Age_Category, fill=..x..))+
  geom_density_ridges_gradient(scale=3, rel_min_height=0.01)+
  scale_fill_viridis(name="Mass_mg",option="C")+
  labs(title='Mass of Surface Morph by Age')+
  theme_ipsum()+
  theme(
    legend.position = 'none',
    panel.spacing = unit(0.1,'lines'),
    strip.text.x = element_text(size=8)
  ) +
  facet_wrap(~Feed_Group,ncol=1)


#Box plot of Mass vs Age for Groups

ggplot(df_growth,aes(y=Mass_mg, x=Age_Category,fill=Feed_Group)) + geom_boxplot(outlier.color='red',outlier.shape=1)+geom_point(position=position_dodge(width=0.75))

#Box plot of Length vs Age for Groups

ggplot(df_growth,aes(y=Length_mm, x=Age_Category,fill=Feed_Group)) + geom_boxplot(outlier.color='red',outlier.shape=1)

#Violin plot
ggplot(df_growth,aes(y=Mass_mg, x=Age_Category,fill=Feed_Group)) + geom_violin()+stat_summary(fun=median,geom='point',size=2,color='red')+
  facet_wrap(~Feed_Group)+theme_bw()+theme(axis.text.x=element_text(angle=45,hjust=1))

ggplot(df_growth,aes(y=Length_mm, x=Age_Category,fill=Feed_Group)) + geom_violin()+stat_summary(fun=median,geom='point',size=2,color='red')+
  facet_wrap(~Feed_Group)+theme_bw()+theme(axis.text.x=element_text(angle=45,hjust=1))

#Understanding growth based on Age category
ggplot(df_growth, aes(y=Age_Category,x=Mass_mg, color=Feed_Group))+geom_point(alpha=0.5)
ggplot(df_growth, aes(y=Age_Category,x=Length_mm, color=Feed_Group))+geom_point(alpha=0.5)


```
## Mass Boxplot Outliers
Lets take a look at our outliers from the previous analysis

```{r Mass Outliers Boxplots}
#descriptive statistics
growth_gemma_outlier_df <- df_growth %>% filter(Feed_Group == "Gemma")

growth_mysis_outlier_df <- df_growth %>% filter(Feed_Group == "Mysis")

summary(growth_mysis_outlier_df$Mass_mg)


#Find boxplot statistics. First we need to summarize a list from groups
growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(boxplot = list(setNames(boxplot.stats(Mass_mg)$stats, 
                                    c('lower_whisker','lower quartile',
                                      'median','upper quartile','upper whisker')))) %>%
#using tidyr unnest_wider function we can pull out the stats information
  unnest_wider(boxplot)


#Find boxplot statistics. First we need to summarize a list from groups
growth_mysis_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(boxplot = list(setNames(boxplot.stats(Mass_mg)$stats, 
                                    c('lower_whisker','lower quartile',
                                      'median','upper quartile','upper whisker')))) %>%
  unnest_wider(boxplot)


#Find outliers from earlier using stats. First we need to summarize a list from groups
gemma_outliers_mass <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>% 
  summarize(boxplot =boxplot.stats(Mass_mg)$out) %>%
  unnest_wider(boxplot)

#Find outliers from earlier using stats. First we need to summarize a list from groups
mysis_outliers_mass <- growth_mysis_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(boxplot = boxplot.stats(Mass_mg)$out) %>%
  unnest_wider(boxplot)


#Now that we know there are outliers, lets grab a dataframe from each of them.
#Using the previous work, we can add the which() function to tell us where these
#outliers live and then filter our dataset around that.

#Finding outliers by value without filtering for age, causes issues where
#an outlier for a certain age is not an outlier elsewhere but is chosen elsewhere 
#because it has the same value (e.g. 2337 @ Five Months and Twelve Months). 
#To the mass matching, we will also match the age

#for loop to run through the rows in the boxplot outlier tibble
#filter the dataframe for each row of the tibble, first by age category, then by outlier data
#add to a new dataframe. Repeat with both sets of data. 

mysis_mass_boxplot_outlier_df <- data.frame()
for (i in 1:nrow(mysis_outliers_mass)) {
 temp_df <-growth_mysis_outlier_df %>%
 filter(.,Age_Category==mysis_outliers_mass[[i,"Age_Category"]]) %>%
   filter(., Mass_mg == mysis_outliers_mass[[i,"...1"]])
 mysis_mass_boxplot_outlier_df <- rbind(mysis_mass_boxplot_outlier_df,temp_df)
}


gemma_mass_boxplot_outlier_df <- data.frame()
for (i in 1:nrow(gemma_outliers_mass)) {
 temp_df <-growth_gemma_outlier_df %>%
 filter(.,Age_Category==gemma_outliers_mass[[i,"Age_Category"]]) %>%
   filter(., Mass_mg == gemma_outliers_mass[[i,"...1"]])
 gemma_mass_boxplot_outlier_df <- rbind(gemma_mass_boxplot_outlier_df,temp_df)
}






```


##Normal Probability Plot
In order to understand our outliers, we need to assume that there is a normal
distribution of data. We will check our normality assumoption with a normal probabilty 
plot.

```{r Normal Probability Plot of Each Age Category for Mass and Length}
#Mass
#iterate through the age levels of the gemma database, create a normal plot for each
#age group using qqplotr and ggplot
for (AgeCategory in levels(growth_gemma_outlier_df$Age_Category)){
  Group_df <- growth_gemma_outlier_df %>%
  filter(Age_Category == AgeCategory)
  #Mass Normal Distribution for each Age
  v <- ggplot(mapping = aes(sample =Group_df$Mass_mg)) + stat_qq_point(size = 2) +
    stat_qq_line(color = "green") + xlab("Normal N(0,1) Order Statistic Medians") +
    ylab("Ordered Response") + labs(title = paste("Gemma Mass Normal Probabilty Plot: ", AgeCategory))
  print(v)
  }

#same for Mysis
for (AgeCategory in levels(growth_mysis_outlier_df$Age_Category)){
  Group_df <- growth_mysis_outlier_df %>%
  filter(Age_Category == AgeCategory)
  #Mass Normal Distribution for each Age
  v <- ggplot(mapping = aes(sample =Group_df$Mass_mg)) + stat_qq_point(size = 2) +
    stat_qq_line(color = "green") + xlab("Normal N(0,1) Order Statistic Medians") +
    ylab("Ordered Response") + labs(title = paste("Mysis Mass Normal Probabilty Plot: ", AgeCategory))
  print(v)
  }
#Length Normal Distribution for each Age
#iterate through the age levels of the gemma database, create a normal plot for each
#age group using qqplotr and ggplot
for (AgeCategory in levels(growth_gemma_outlier_df$Age_Category)){
  Group_df <- growth_gemma_outlier_df %>%
  filter(Age_Category == AgeCategory)
  #Mass Normal Distribution for each Age
  v <- ggplot(mapping = aes(sample =Group_df$Length_mm)) + stat_qq_point(size = 2) +
    stat_qq_line(color = "green") + xlab("Normal N(0,1) Order Statistic Medians") +
    ylab("Ordered Response") + labs(title = paste("Gemma Length Normal Probabilty Plot: ", AgeCategory))
  print(v)
  }

#same for Mysis
for (AgeCategory in levels(growth_mysis_outlier_df$Age_Category)){
  Group_df <- growth_mysis_outlier_df %>%
  filter(Age_Category == AgeCategory)
  #Mass Normal Distribution for each Age
  v <- ggplot(mapping = aes(sample =Group_df$Length_mm)) + stat_qq_point(size = 2) +
    stat_qq_line(color = "green") + xlab("Normal N(0,1) Order Statistic Medians") +
    ylab("Ordered Response") + labs(title = paste("Mysis Length Normal Probabilty Plot: ", AgeCategory))
  print(v)
  }


```
Although the outliers are causing our distribution to skew, because we have over 
50 samples per age per group, we will use the CLT to assume normality. 




# Mass Percentile Outliers
Percentile outliers will flag any sample outside 2.5 and 97.5 percentiles. 

```{r Mass Outliers Percentiles}

#For each age category we will find the 2.5% bound  using the qunatile() func.
lower_bound_gemma <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(quantile(Mass_mg, 0.025))


#For each age category we will find the 97.5% bound  using the qunatile() func.
upper_bound_gemma <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(quantile(Mass_mg, 0.975))

#For each age category we will find the 2.5% bound  using the qunatile() func.
lower_bound_mysis <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(quantile(Mass_mg, 0.025))

#For each age category we will find the 97.5% bound  using the qunatile() func.
upper_bound_mysis <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(quantile(Mass_mg, 0.975))


#percentile df of the outliers
gemma_mass_percentile_outlier_df <- data.frame()
for (AgeCategory in levels(growth_gemma_outlier_df$Age_Category)){
  #iterate through all age categories filtering any values outside the category's bounds
  temp_df <- growth_gemma_outlier_df %>%
    filter(Age_Category == AgeCategory) %>%
    filter(Mass_mg < lower_bound_gemma$`quantile(Mass_mg, 0.025)`[lower_bound_gemma$Age_Category==AgeCategory] | 
           Mass_mg > upper_bound_gemma$`quantile(Mass_mg, 0.975)`[upper_bound_gemma$Age_Category==AgeCategory])
  gemma_mass_percentile_outlier_df <-rbind(gemma_mass_percentile_outlier_df,temp_df)
  }
  

mysis_mass_percentile_outlier_df <- data.frame()
for (AgeCategory in levels(growth_mysis_outlier_df$Age_Category)){
  #iterate through all age categories filtering any values outside the category's bounds
    temp_df_mysis <- growth_mysis_outlier_df %>%
    filter(Age_Category == AgeCategory) %>%
    filter(Mass_mg < lower_bound_mysis$`quantile(Mass_mg, 0.025)`[lower_bound_mysis$Age_Category==AgeCategory] | 
           Mass_mg > upper_bound_mysis$`quantile(Mass_mg, 0.975)`[upper_bound_mysis$Age_Category==AgeCategory])
  mysis_mass_percentile_outlier_df  <-rbind(mysis_mass_percentile_outlier_df,temp_df_mysis)
  }
  

```

## Mass Generalized ESD Test for Outliers
Generalized ESD test is used to detect one or more outliers in a univariate dataset
for approximate normal distribution. We do not have to specify the number of outliers, just an upper bound.

```{r Rosner's GESD Test for Mass Outliers}
#Create empty dataframe
gemma_mass_rosner_outlier_df <- data.frame()
#iterate through age categories and create temp df for that age category
for (AgeCategory in levels(growth_gemma_outlier_df$Age_Category)){
  Group_df <- growth_gemma_outlier_df %>%
  filter(Age_Category == AgeCategory)

  #use rosner test function to find outliers (max 10) for each age category 
  
  gemma_rosner_mass <- rosnerTest(Group_df$Mass_mg,k=10, alpha = 0.05)
  #create temp df where only outliers exist
  temp_df <- gemma_rosner_mass[["all.stats"]] %>%
    filter(Outlier == TRUE)
  #filter the age df based on the observation row number provided
  gemma_rosner_outlier_loc <- Group_df %>% filter(row_number() %in% temp_df$Obs.Num)
  #append to new df
  gemma_mass_rosner_outlier_df <-rbind(gemma_mass_rosner_outlier_df,gemma_rosner_outlier_loc)
}

#Create empty dataframe
mysis_mass_rosner_outlier_df <- data.frame()
#iterate through age categories and create temp df for that age category
for (AgeCategory in levels(growth_mysis_outlier_df$Age_Category)){
  Group_df <- growth_mysis_outlier_df %>%
  filter(Age_Category == AgeCategory)

  #use rosner test function to find outliers (max 10) for each age category 
  
  mysis_rosner_mass <- rosnerTest(Group_df$Mass_mg,k=10, alpha = 0.05)
  #create temp df where only outliers exist
  temp_df <- mysis_rosner_mass[["all.stats"]] %>%
    filter(Outlier == TRUE)
  #filter the age df based on the observation row number provided
  mysis_rosner_outlier_loc <- Group_df %>% filter(row_number() %in% temp_df$Obs.Num)
  #append to new df
  mysis_mass_rosner_outlier_df <-rbind(mysis_mass_rosner_outlier_df,mysis_rosner_outlier_loc)
}


```


#Mass Cooks Distance Outliers
This wonderful outlier detection method estimates the amount of influence each 
observation has on the over all regression model. It does this by removing each 
observation and calculating the change in the model. A general rule is outliers
are 3x the mean of all the distances. Because it's based on regression model,
only the X variable has impact on the outcome, which allows us to see the amount
of influce a sample has on the predicted outcome. The measurement is the change in Y
for all observations with and without the sample.

```{r Cooks Distance Outliers}
gemma_mass_cooksd_outlier_df <- data.frame()
mysis_mass_cooksd_outlier_df <- data.frame()


for (AgeCategory in levels(growth_gemma_outlier_df$Age_Category)){
  Group_df <- growth_gemma_outlier_df %>%
  filter(Age_Category == AgeCategory)

#create linear regression model for Mass. We will use the Log of Mass and  Length
  #we use the log based on previous information telling us length-mass is not a 
  #strictly linear relationship
  model <- lm(Mass_mg ~ Length_mm, data = Group_df)
  summary(model)
  
#look at diagnostic plots for outliers
  par(mfrow = c(2,2))
  plot(model)

  #based on the residual vs leverage models, we can see some outliers have large 
  #impact on our models
  
  #looking at cooks distance. picking out any observations that are 3x the mean of cooksD
 cooksD <- cooks.distance(model)
 influencial <- cooksD[(cooksD > (3 * mean(cooksD, na.rm =TRUE)))]
 
 plot(cooksD, pch="*", cex=2, main = "Influential Obs by Cooks distance") #plot cooks distance
 abline(h = 3 * mean(cooksD, na.rm =TRUE),col="red") # add cutoff line
 text(x=1:length(cooksD)+1, y=cooksD, labels =ifelse(cooksD>3 * mean(cooksD, na.rm =TRUE),names(cooksD),""),col="red") #add labels
 
   #filter the age df based on the observation row number provided
  gemma_cooksd_outlier_loc <- Group_df %>% filter(row_number() %in% names(influencial))
  #append to new df
  gemma_mass_cooksd_outlier_df <-rbind(gemma_mass_cooksd_outlier_df,gemma_cooksd_outlier_loc)
 
 
}


for (AgeCategory in levels(growth_mysis_outlier_df$Age_Category)){
  Group_df <- growth_mysis_outlier_df %>%
  filter(Age_Category == AgeCategory)

#create linear regression model for Mass. We will use the Log of Mass and  Length
  #we use the log based on previous information telling us length-mass is not a 
  #strictly linear relationship
  model <- lm(Mass_mg ~ Length_mm, data = Group_df)
  summary(model)
  
#look at diagnostic plots for outliers
  par(mfrow = c(2,2))
  plot(model)

  #based on the residual vs leverage models, we can see some outliers have large 
  #impact on our models
  
  #looking at cooks distance. picking out any observations that are 3x the mean of cooksD
 cooksD <- cooks.distance(model)
 influencial <- cooksD[(cooksD > (3 * mean(cooksD, na.rm =TRUE)))]
 
 plot(cooksD, pch="*", cex=2, main = "Influential Obs by Cooks distance") #plot cooks distance
 abline(h = 3 * mean(cooksD, na.rm =TRUE),col="red") # add cutoff line
 text(x=1:length(cooksD)+1, y=cooksD, labels =ifelse(cooksD>3 * mean(cooksD, na.rm =TRUE),names(cooksD),""),col="red") #add labels
 
   #filter the age df based on the observation row number provided
  mysis_cooksd_outlier_loc <- Group_df %>% filter(row_number() %in% names(influencial))
  #append to new df
  mysis_mass_cooksd_outlier_df <-rbind(mysis_mass_cooksd_outlier_df,mysis_cooksd_outlier_loc)
 
 
}

```



# Mass Outlier Comparison
Will all these potential outliers, this study actually becomes a great tool to 
look at outliers and what they mean. this section will be comparing all the 
different methods of outlier detection and the overlap in outliers detected

```{r Mass Outlier Summary}

#Grab Datasets from each detection method

#BoxPlot
mysis_mass_boxplot_outlier_df
gemma_mass_boxplot_outlier_df

#Percentile
mysis_mass_percentile_outlier_df
gemma_mass_percentile_outlier_df

#Rosner
mysis_mass_rosner_outlier_df
gemma_mass_rosner_outlier_df

#CooksD

mysis_mass_cooksd_outlier_df 
gemma_mass_cooksd_outlier_df


#Create a dataframe for each group (mysis and gemma) that represents all distinct
#outlier possibilities across the 4 methods

#I will use dplyr anti-join to 

#Mysis
#create new summary df based on the first antijoin df
mysis_mass_summary_outlier_df <- mysis_mass_boxplot_outlier_df

#use anti join to find differences in dataframe
mysis_list_outlier_df <- list(mysis_mass_boxplot_outlier_df, mysis_mass_percentile_outlier_df,
                              mysis_mass_rosner_outlier_df, mysis_mass_cooksd_outlier_df)
  

for (outlier_dfs in mysis_list_outlier_df) {
  outlier_difference <- anti_join(outlier_dfs,mysis_mass_summary_outlier_df)

  #append to summary df 
  mysis_mass_summary_outlier_df <-rbind(mysis_mass_summary_outlier_df,outlier_difference)
}
#reorder and reset index of dataframe
mysis_mass_summary_outlier_df <- mysis_mass_summary_outlier_df %>% arrange(Sample_ID)
row.names(mysis_mass_summary_outlier_df) <-NULL


#Gemma
#create new summary df based on the first antijoin df
gemma_mass_summary_outlier_df <- gemma_mass_boxplot_outlier_df

#use anti join to find differences in dataframe
gemma_list_outlier_df <- list(gemma_mass_boxplot_outlier_df, gemma_mass_percentile_outlier_df,
                              gemma_mass_rosner_outlier_df, gemma_mass_cooksd_outlier_df)
  

for (outlier_dfs in gemma_list_outlier_df) {
  outlier_difference <- anti_join(outlier_dfs,gemma_mass_summary_outlier_df)

  #append to summary df 
  gemma_mass_summary_outlier_df <-rbind(gemma_mass_summary_outlier_df,outlier_difference)
}
#reorder and reset index of dataframe
gemma_mass_summary_outlier_df <- gemma_mass_summary_outlier_df %>% arrange(Sample_ID)
row.names(gemma_mass_summary_outlier_df) <-NULL


#With the two summary tables, now we can strip the information and create a
#dataframe that shows which outliers were counted by which methods


mysis_mass_outlier_method_df <-  subset(mysis_mass_summary_outlier_df,
                                        select=-c(Date, Tank, Feed_Group, Length_mm)) 
gemma_mass_outlier_method_df <-  subset(gemma_mass_summary_outlier_df,
                                        select=-c(Date, Tank, Feed_Group, Length_mm)) 

#add columns for each method
methods_list = list("Boxplot", "Percentile", "Rosner", "CooksD")

for (method in methods_list){
  mysis_mass_outlier_method_df <- mysis_mass_outlier_method_df %>% 
    add_column(!!(method) :=0)
  gemma_mass_outlier_method_df <- gemma_mass_outlier_method_df %>%
    add_column(!!(method) :=0)
}


#Add +1 to any method that detected the sample ID. We are adding 1 so that when we
#do this same process with length, we can see which are only length or mass outliers
#vs both outliers (which may just be a larger fish, but still falls on the growth curve)



for (sample_ID in mysis_mass_outlier_method_df$Sample_ID){
  if (sample_ID %in% mysis_mass_boxplot_outlier_df$Sample_ID){
    mysis_mass_outlier_method_df["Boxplot"][mysis_mass_outlier_method_df["Sample_ID"] == sample_ID] <- 1
  }

  if (sample_ID %in% mysis_mass_percentile_outlier_df$Sample_ID){
    mysis_mass_outlier_method_df["Percentile"][mysis_mass_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  

  if (sample_ID %in% mysis_mass_rosner_outlier_df$Sample_ID){
    mysis_mass_outlier_method_df["Rosner"][mysis_mass_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  
  if (sample_ID %in% mysis_mass_cooksd_outlier_df$Sample_ID){
    mysis_mass_outlier_method_df["CooksD"][mysis_mass_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  
  
}

#gemma
for (sample_ID in gemma_mass_outlier_method_df$Sample_ID){
  if (sample_ID %in% gemma_mass_boxplot_outlier_df$Sample_ID){
    gemma_mass_outlier_method_df["Boxplot"][gemma_mass_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }

  if (sample_ID %in% gemma_mass_percentile_outlier_df$Sample_ID){
    gemma_mass_outlier_method_df["Percentile"][gemma_mass_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  

  if (sample_ID %in% gemma_mass_rosner_outlier_df$Sample_ID){
    gemma_mass_outlier_method_df["Rosner"][gemma_mass_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  
  if (sample_ID %in% gemma_mass_cooksd_outlier_df$Sample_ID){
    gemma_mass_outlier_method_df["CooksD"][gemma_mass_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  
  
}

#Create a total of outlier methods detecting one sample

mysis_mass_outlier_method_df <- mysis_mass_outlier_method_df %>%
 mutate(Total = select(., Boxplot:CooksD) %>% rowSums(na.rm =TRUE))

gemma_mass_outlier_method_df <- gemma_mass_outlier_method_df %>%
 mutate(Total = select(., Boxplot:CooksD) %>% rowSums(na.rm =TRUE))


#Add a Mass_outlier column and place the total numbers for each outlier sample 
#so they can be used to plot

for (Sample in growth_mysis_outlier_df$Sample_ID) {
  if (Sample %in% mysis_mass_outlier_method_df$Sample_ID){
    growth_mysis_outlier_df$Mass_Outlier[growth_mysis_outlier_df["Sample_ID"]==Sample] <- 
      mysis_mass_outlier_method_df$Total[mysis_mass_outlier_method_df["Sample_ID"] == Sample]
    
  } 
  else{
    growth_mysis_outlier_df$Mass_Outlier[growth_mysis_outlier_df["Sample_ID"]==Sample] <- 0
  }
    
}



for (Sample in growth_gemma_outlier_df$Sample_ID) {
  if (Sample %in% gemma_mass_outlier_method_df$Sample_ID){
    growth_gemma_outlier_df$Mass_Outlier[growth_gemma_outlier_df["Sample_ID"]==Sample] <- 
      gemma_mass_outlier_method_df$Total[gemma_mass_outlier_method_df["Sample_ID"] == Sample]
    
  } 
  else{
    growth_gemma_outlier_df$Mass_Outlier[growth_gemma_outlier_df["Sample_ID"]==Sample] <- 0
  }
    
}



#create factor levels to map discrete rather than continuous values for outlier count
growth_mysis_outlier_df$Mass_Outlier <-factor(growth_mysis_outlier_df$Mass_Outlier, 
                                 levels = c("4","3","2","1","0"))

growth_gemma_outlier_df$Mass_Outlier <-factor(growth_gemma_outlier_df$Mass_Outlier, 
                                 levels = c("4","3","2","1","0"))



#plot outlier frequency based on method selection
ggplot(growth_mysis_outlier_df, aes(x = Length_mm, y = Mass_mg, color = Mass_Outlier)) +
  geom_point()+scale_color_brewer(palette="Set1") 
ggplot(growth_gemma_outlier_df, aes(x = Length_mm, y = Mass_mg, color = Mass_Outlier)) +
  geom_point()+scale_color_brewer(palette="Set1") 


ggplot(growth_mysis_outlier_df, aes(y=Mass_mg, x=Age_Category)) + geom_boxplot() + 
  geom_point(aes(color = Mass_Outlier))+scale_color_brewer(palette="Set1") + theme_classic()

ggplot(growth_gemma_outlier_df, aes(y=Mass_mg, x=Age_Category)) + geom_boxplot() + 
  geom_point(aes(color = Mass_Outlier))+scale_color_brewer(palette="Set1") + theme_classic()


ggplot(growth_mysis_outlier_df, aes(y=Mass_mg, x=Tank,color=Age_Category)) + geom_boxplot(aes(color=Age_Category))+
 theme_classic()

ggplot(growth_mysis_outlier_df, aes(y=Mass_mg, x=Age_Category,color=Tank)) + geom_boxplot(aes(color=Tank))+
  theme_classic()
```




## Length Boxplot Outliers


```{r Length Outlier Boxplot}

summary(growth_mysis_outlier_df$Length_mm)
summary(growth_gemma_outlier_df$Length_mm)

#Find boxplot statistics. First we need to summarize a list from groups
Length_Gemma_Stats <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(boxplot = list(setNames(boxplot.stats(Length_mm)$stats, 
                                    c('lower_whisker','lower quartile',
                                      'median','upper quartile','upper whisker')))) %>%
  unnest_wider(boxplot)

#Find boxplot statistics. First we need to summarize a list from groups
Length_Mysis_Stats <- growth_mysis_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(boxplot = list(setNames(boxplot.stats(Length_mm)$stats, 
                                    c('lower_whisker','lower quartile',
                                      'median','upper quartile','upper whisker')))) %>%
  unnest_wider(boxplot)




#Find outliers from earlier using stats. First we need to summarize a list from groups
gemma_outliers_length <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(boxplot =boxplot.stats(Length_mm)$out) %>%
  unnest_wider(boxplot)

#Find outliers from earlier using stats. First we need to summarize a list from groups
mysis_outliers_length <- growth_mysis_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(boxplot = boxplot.stats(Length_mm)$out) %>%
  unnest_wider(boxplot)


#Now that we know there are outliers, lets grab a dataframe from each of them.
#Using the previous work, we can add the which() function to tell us where these
#outliers live and then filter our dataset around that.

mysis_length_boxplot_outlier_df <- data.frame()
for (i in 1:nrow(mysis_outliers_length)) {
 temp_df <-growth_mysis_outlier_df %>%
 filter(.,Age_Category==mysis_outliers_length[[i,"Age_Category"]]) %>%
   filter(., Length_mm == mysis_outliers_length[[i,"...1"]])
 mysis_length_boxplot_outlier_df <- rbind(mysis_length_boxplot_outlier_df,temp_df)
}


gemma_length_boxplot_outlier_df <- data.frame()
for (i in 1:nrow(gemma_outliers_length)) {
 temp_df <-growth_gemma_outlier_df %>%
 filter(.,Age_Category==gemma_outliers_length[[i,"Age_Category"]]) %>%
   filter(., Length_mm == gemma_outliers_length[[i,"...1"]])
 gemma_length_boxplot_outlier_df <- rbind(gemma_length_boxplot_outlier_df,temp_df)
}







```

# Length Percentile Outliers
Percentile outliers will flag any sample outside 2.5 and 97.5 percentiles. 

```{r Length Outliers Percentiles}

#For each age category we will find the 2.5% bound  using the qunatile() func.
lower_bound_gemma <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(quantile(Length_mm, 0.025))


#For each age category we will find the 97.5% bound  using the qunatile() func.
upper_bound_gemma <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(quantile(Length_mm, 0.975))

#For each age category we will find the 2.5% bound  using the qunatile() func.
lower_bound_mysis <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(quantile(Length_mm, 0.025))

#For each age category we will find the 97.5% bound  using the qunatile() func.
upper_bound_mysis <- growth_gemma_outlier_df %>%
  group_by(Age_Category) %>%
  summarize(quantile(Length_mm, 0.975))


#percentile df of the outliers
gemma_length_percentile_outlier_df <- data.frame()
for (AgeCategory in levels(growth_gemma_outlier_df$Age_Category)){
  #iterate through all age categories filtering any values outside the category's bounds
  temp_df <- growth_gemma_outlier_df %>%
    filter(Age_Category == AgeCategory) %>%
    filter(Length_mm < lower_bound_gemma$`quantile(Length_mm, 0.025)`[lower_bound_gemma$Age_Category==AgeCategory] | 
           Length_mm > upper_bound_gemma$`quantile(Length_mm, 0.975)`[upper_bound_gemma$Age_Category==AgeCategory])
  gemma_length_percentile_outlier_df <-rbind(gemma_length_percentile_outlier_df,temp_df)
  }
  

mysis_length_percentile_outlier_df <- data.frame()
for (AgeCategory in levels(growth_mysis_outlier_df$Age_Category)){
  #iterate through all age categories filtering any values outside the category's bounds
    temp_df_mysis <- growth_mysis_outlier_df %>%
    filter(Age_Category == AgeCategory) %>%
    filter(Length_mm < lower_bound_mysis$`quantile(Length_mm, 0.025)`[lower_bound_mysis$Age_Category==AgeCategory] | 
           Length_mm > upper_bound_mysis$`quantile(Length_mm, 0.975)`[upper_bound_mysis$Age_Category==AgeCategory])
  mysis_length_percentile_outlier_df  <-rbind(mysis_length_percentile_outlier_df,temp_df_mysis)
  }
  

```

## length Generalized ESD Test for Outliers
Generalized ESD test is used to detect one or more outliers in a univariate dataset
for approximate normal distribution. We do not have to specify the number of outliers, just an upper bound.

```{r Rosner's GESD Test for length Outliers}
#Create empty dataframe
gemma_length_rosner_outlier_df <- data.frame()
#iterate through age categories and create temp df for that age category
for (AgeCategory in levels(growth_gemma_outlier_df$Age_Category)){
  Group_df <- growth_gemma_outlier_df %>%
  filter(Age_Category == AgeCategory)

  #use rosner test function to find outliers (max 10) for each age category 
  
  gemma_rosner_length <- rosnerTest(Group_df$Length_mm,k=10, alpha = 0.05)
  #create temp df where only outliers exist
  temp_df <- gemma_rosner_length[["all.stats"]] %>%
    filter(Outlier == TRUE)
  #filter the age df based on the observation row number provided
  gemma_rosner_outlier_loc <- Group_df %>% filter(row_number() %in% temp_df$Obs.Num)
  #append to new df
  gemma_length_rosner_outlier_df <-rbind(gemma_length_rosner_outlier_df,gemma_rosner_outlier_loc)
}

#Create empty dataframe
mysis_length_rosner_outlier_df <- data.frame()
#iterate through age categories and create temp df for that age category
for (AgeCategory in levels(growth_mysis_outlier_df$Age_Category)){
  Group_df <- growth_mysis_outlier_df %>%
  filter(Age_Category == AgeCategory)

  #use rosner test function to find outliers (max 10) for each age category 
  
  mysis_rosner_length <- rosnerTest(Group_df$Length_mm,k=10, alpha = 0.05)
  #create temp df where only outliers exist
  temp_df <- mysis_rosner_length[["all.stats"]] %>%
    filter(Outlier == TRUE)
  #filter the age df based on the observation row number provided
  mysis_rosner_outlier_loc <- Group_df %>% filter(row_number() %in% temp_df$Obs.Num)
  #append to new df
  mysis_length_rosner_outlier_df <-rbind(mysis_length_rosner_outlier_df,mysis_rosner_outlier_loc)
}


```


#length Cooks Distance Outliers
This wonderful outlier detection method estimates the amount of influence each 
observation has on the over all regression model. It does this by removing each 
observation and calculating the change in the model. A general rule is outliers
are 3x the mean of all the distances. Because it's based on regression model,
only the X variable has impact on the outcome, which allows us to see the amount
of influce a sample has on the predicted outcome. The measurement is the change in Y
for all observations with and without the sample.

```{r Cooks Distance Outliers}
gemma_length_cooksd_outlier_df <- data.frame()
mysis_length_cooksd_outlier_df <- data.frame()


for (AgeCategory in levels(growth_gemma_outlier_df$Age_Category)){
  Group_df <- growth_gemma_outlier_df %>%
  filter(Age_Category == AgeCategory)

#create linear regression model for length. We will use the Log of length and  Mss
  #we use the log based on previous information telling us length is not a 
  #strictly linear relationship
  model <- lm(Mass_mg ~ Length_mm, data = Group_df)
  summary(model)
  
#look at diagnostic plots for outliers
  par(mfrow = c(2,2))
  plot(model)

  #based on the residual vs leverage models, we can see some outliers have large 
  #impact on our models
  
  #looking at cooks distance. picking out any observations that are 3x the mean of cooksD
 cooksD <- cooks.distance(model)
 influencial <- cooksD[(cooksD > (3 * mean(cooksD, na.rm =TRUE)))]
 
 plot(cooksD, pch="*", cex=2, main = "Influential Obs by Cooks distance") #plot cooks distance
 abline(h = 3 * mean(cooksD, na.rm =TRUE),col="red") # add cutoff line
 text(x=1:length(cooksD)+1, y=cooksD, labels =ifelse(cooksD>3 * mean(cooksD, na.rm =TRUE),names(cooksD),""),col="red") #add labels
 
   #filter the age df based on the observation row number provided
  gemma_cooksd_outlier_loc <- Group_df %>% filter(row_number() %in% names(influencial))
  #append to new df
  gemma_length_cooksd_outlier_df <-rbind(gemma_length_cooksd_outlier_df,gemma_cooksd_outlier_loc)
 
 
}


for (AgeCategory in levels(growth_mysis_outlier_df$Age_Category)){
  Group_df <- growth_mysis_outlier_df %>%
  filter(Age_Category == AgeCategory)

#create linear regression model for Mass. We will use the Log of Mass and  Length
  #we use the log based on previous information telling us length-mass is not a 
  #strictly linear relationship
  model <- lm(Mass_mg ~ Length_mm, data = Group_df)
  summary(model)
  
#look at diagnostic plots for outliers
  par(mfrow = c(2,2))
  plot(model)

  #based on the residual vs leverage models, we can see some outliers have large 
  #impact on our models
  
  #looking at cooks distance. picking out any observations that are 3x the mean of cooksD
 cooksD <- cooks.distance(model)
 influencial <- cooksD[(cooksD > (3 * mean(cooksD, na.rm =TRUE)))]
 
 plot(cooksD, pch="*", cex=2, main = "Influential Obs by Cooks distance") #plot cooks distance
 abline(h = 3 * mean(cooksD, na.rm =TRUE),col="red") # add cutoff line
 text(x=1:length(cooksD)+1, y=cooksD, labels =ifelse(cooksD>3 * mean(cooksD, na.rm =TRUE),names(cooksD),""),col="red") #add labels
 
   #filter the age df based on the observation row number provided
  mysis_cooksd_outlier_loc <- Group_df %>% filter(row_number() %in% names(influencial))
  #append to new df
  mysis_length_cooksd_outlier_df <-rbind(mysis_length_cooksd_outlier_df,mysis_cooksd_outlier_loc)
 
 
}

```



# Length Outlier Comparison
Will all these potential outliers, this study actually becomes a great tool to 
look at outliers and what they mean. this section will be comparing all the 
different methods of outlier detection and the overlap in outliers detected

```{r length Outlier Summary}

#Grab Datasets from each detection method

#BoxPlot
mysis_length_boxplot_outlier_df
gemma_length_boxplot_outlier_df

#Percentile
mysis_length_percentile_outlier_df
gemma_length_percentile_outlier_df

#Rosner
mysis_length_rosner_outlier_df
gemma_length_rosner_outlier_df

#CooksD

mysis_length_cooksd_outlier_df 
gemma_length_cooksd_outlier_df


#Create a dataframe for each group (mysis and gemma) that represents all distinct
#outlier possibilities across the 4 methods

#I will use dplyr anti-join to 

#Mysis
#create new summary df based on the first antijoin df
mysis_length_summary_outlier_df <- mysis_length_boxplot_outlier_df

#use anti join to find differences in dataframe
mysis_list_outlier_df <- list(mysis_length_boxplot_outlier_df, mysis_length_percentile_outlier_df,
                              mysis_length_rosner_outlier_df, mysis_length_cooksd_outlier_df)
  

for (outlier_dfs in mysis_list_outlier_df) {
  outlier_difference <- anti_join(outlier_dfs,mysis_length_summary_outlier_df)

  #append to summary df 
  mysis_length_summary_outlier_df <-rbind(mysis_length_summary_outlier_df,outlier_difference)
}
#reorder and reset index of dataframe
mysis_length_summary_outlier_df <- mysis_length_summary_outlier_df %>% arrange(Sample_ID)
row.names(mysis_length_summary_outlier_df) <-NULL


#Gemma
#create new summary df based on the first antijoin df
gemma_length_summary_outlier_df <- gemma_length_boxplot_outlier_df

#use anti join to find differences in dataframe
gemma_list_outlier_df <- list(gemma_length_boxplot_outlier_df, gemma_length_percentile_outlier_df,
                              gemma_length_rosner_outlier_df, gemma_length_cooksd_outlier_df)
  

for (outlier_dfs in gemma_list_outlier_df) {
  outlier_difference <- anti_join(outlier_dfs,gemma_length_summary_outlier_df)

  #append to summary df 
  gemma_length_summary_outlier_df <-rbind(gemma_length_summary_outlier_df,outlier_difference)
}
#reorder and reset index of dataframe
gemma_length_summary_outlier_df <- gemma_length_summary_outlier_df %>% arrange(Sample_ID)
row.names(gemma_length_summary_outlier_df) <-NULL


#With the two summary tables, now we can strip the information and create a
#dataframe that shows which outliers were counted by which methods


mysis_length_outlier_method_df <-  subset(mysis_length_summary_outlier_df,
                                        select=-c(Date, Tank, Feed_Group, Mass_mg)) 
gemma_length_outlier_method_df <-  subset(gemma_length_summary_outlier_df,
                                        select=-c(Date, Tank, Feed_Group, Mass_mg)) 

#add columns for each method
methods_list = list("Boxplot", "Percentile", "Rosner", "CooksD")

for (method in methods_list){
  mysis_length_outlier_method_df <- mysis_length_outlier_method_df %>% 
    add_column(!!(method) :=0)
  gemma_length_outlier_method_df <- gemma_length_outlier_method_df %>%
    add_column(!!(method) :=0)
}


#Add +1 to any method that detected the sample ID. We are adding 1 so that when we
#do this same process with length, we can see which are only length or length outliers
#vs both outliers (which may just be a larger fish, but still falls on the growth curve)



for (sample_ID in mysis_length_outlier_method_df$Sample_ID){
  if (sample_ID %in% mysis_length_boxplot_outlier_df$Sample_ID){
    mysis_length_outlier_method_df["Boxplot"][mysis_length_outlier_method_df["Sample_ID"] == sample_ID] <- 1
  }

  if (sample_ID %in% mysis_length_percentile_outlier_df$Sample_ID){
    mysis_length_outlier_method_df["Percentile"][mysis_length_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  

  if (sample_ID %in% mysis_length_rosner_outlier_df$Sample_ID){
    mysis_length_outlier_method_df["Rosner"][mysis_length_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  
  if (sample_ID %in% mysis_length_cooksd_outlier_df$Sample_ID){
    mysis_length_outlier_method_df["CooksD"][mysis_length_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  
  
}

#gemma
for (sample_ID in gemma_length_outlier_method_df$Sample_ID){
  if (sample_ID %in% gemma_length_boxplot_outlier_df$Sample_ID){
    gemma_length_outlier_method_df["Boxplot"][gemma_length_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }

  if (sample_ID %in% gemma_length_percentile_outlier_df$Sample_ID){
    gemma_length_outlier_method_df["Percentile"][gemma_length_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  

  if (sample_ID %in% gemma_length_rosner_outlier_df$Sample_ID){
    gemma_length_outlier_method_df["Rosner"][gemma_length_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  
  if (sample_ID %in% gemma_length_cooksd_outlier_df$Sample_ID){
    gemma_length_outlier_method_df["CooksD"][gemma_length_outlier_method_df["Sample_ID"] == sample_ID] <-1
  }
  
  
}

#Create a total of outlier methods detecting one sample

mysis_length_outlier_method_df <- mysis_length_outlier_method_df %>%
 mutate(Total = select(., Boxplot:CooksD) %>% rowSums(na.rm =TRUE))

gemma_length_outlier_method_df <- gemma_length_outlier_method_df %>%
 mutate(Total = select(., Boxplot:CooksD) %>% rowSums(na.rm =TRUE))


#Add a length_outlier column and place the total numbers for each outlier sample 
#so they can be used to plot

for (Sample in growth_mysis_outlier_df$Sample_ID) {
  if (Sample %in% mysis_length_outlier_method_df$Sample_ID){
    growth_mysis_outlier_df$length_Outlier[growth_mysis_outlier_df["Sample_ID"]==Sample] <- 
      mysis_length_outlier_method_df$Total[mysis_length_outlier_method_df["Sample_ID"] == Sample]
    
  } 
  else{
    growth_mysis_outlier_df$length_Outlier[growth_mysis_outlier_df["Sample_ID"]==Sample] <- 0
  }
    
}



for (Sample in growth_gemma_outlier_df$Sample_ID) {
  if (Sample %in% gemma_length_outlier_method_df$Sample_ID){
    growth_gemma_outlier_df$length_Outlier[growth_gemma_outlier_df["Sample_ID"]==Sample] <- 
      gemma_length_outlier_method_df$Total[gemma_length_outlier_method_df["Sample_ID"] == Sample]
    
  } 
  else{
    growth_gemma_outlier_df$length_Outlier[growth_gemma_outlier_df["Sample_ID"]==Sample] <- 0
  }
    
}



#create factor levels to map discrete rather than continuous values for outlier count
growth_mysis_outlier_df$length_Outlier <-factor(growth_mysis_outlier_df$length_Outlier, 
                                 levels = c("4","3","2","1","0"))

growth_gemma_outlier_df$length_Outlier <-factor(growth_gemma_outlier_df$length_Outlier, 
                                 levels = c("4","3","2","1","0"))



#plot outlier frequency based on method selection
ggplot(growth_mysis_outlier_df, aes(x = Length_mm, y = Mass_mg, color = length_Outlier)) +
  geom_point()+scale_color_brewer(palette="Set2") 
ggplot(growth_gemma_outlier_df, aes(x = Length_mm, y = Mass_mg, color = length_Outlier)) +
  geom_point()+scale_color_brewer(palette="Set2") 


ggplot(growth_mysis_outlier_df, aes(y=Length_mm, x=Age_Category)) + geom_boxplot() + 
  geom_point(aes(color = length_Outlier))+scale_color_brewer(palette="Set1") + theme_classic()

ggplot(growth_gemma_outlier_df, aes(y=Length_mm, x=Age_Category)) + geom_boxplot() + 
  geom_point(aes(color = length_Outlier))+scale_color_brewer(palette="Set1") + theme_classic()


ggplot(growth_mysis_outlier_df, aes(y=Length_mm, x=Tank,color=Age_Category)) + geom_boxplot(aes(color=Age_Category))+
 theme_classic()

ggplot(growth_mysis_outlier_df, aes(y=Length_mm, x=Age_Category,color=Tank)) + geom_boxplot(aes(color=Tank))+
  theme_classic()

ggplot(growth_gemma_outlier_df, aes(y=Length_mm, x=Tank,color=Age_Category)) + geom_boxplot(aes(color=Age_Category))+
 theme_classic()

ggplot(growth_gemma_outlier_df, aes(y=Length_mm, x=Age_Category,color=Tank)) + geom_boxplot(aes(color=Tank))+
  theme_classic()

```

## Summarize Outlier Testing
Now that we have an understanding of different methods for outlier collection,
I was curious how similar these methods would be. Which outliers would recieve marks 
from the most methods for detection? Which would only mark one. Do the Mass outliers
correspond to the Length Outliers?

```{r Summary of Oultiers}

# We have made Boxplots, percentile, Rosner, Cooks Distance, and Grubbs. 

growth_mysis_outlier_df
growth_gemma_outlier_df


#Tidy the data
growth_mysis_outlier_tidy_df<-growth_mysis_outlier_df %>%
  pivot_longer(c("Mass_Outlier","length_Outlier"), names_to = "Outliers_Metric", values_to = "Outlier_Count")

#difference in # of samples from both length & mass that each had 1,2,3,4 method counts 
growth_mysis_outlier_tidy_df %>%
ggplot(., aes(x=Outlier_Count,fill=Outliers_Metric ))+geom_bar()

#counts between length and mass of samples that had 0,1,2,3,4 methods 
ggplot(growth_mysis_outlier_tidy_df, aes(x=Outliers_Metric, fill=Outlier_Count ))+geom_bar()


#Counts for total outliers of length and total outliers for mass
total_length_Outlier_Count <- growth_mysis_outlier_tidy_df %>%
  filter(., Outlier_Count != 0)%>%
  filter(.,Outliers_Metric == "length_Outlier") %>%
  nrow()

total_mass_Outlier_Count <- growth_mysis_outlier_tidy_df %>%
  filter(., Outlier_Count != 0)%>%
  filter(.,Outliers_Metric == "Mass_Outlier") %>%
  nrow()


#Using count we will normalize the bar plot so it shows % of # of methods
growth_mysis_outlier_tidy_df %>%
ggplot(., aes(x=Outlier_Count,fill=Outliers_Metric ))+geom_bar()

#scatter plot of length v mass with mass outliers 
growth_mysis_outlier_df %>%
ggplot(., aes(y=Mass_mg, x=Length_mm)) + 
  geom_point(aes(color=Mass_Outlier))
#scatter plot of length v mass with mass outliers 
growth_mysis_outlier_df %>%
ggplot(., aes(y=Mass_mg, x=Length_mm)) + 
  geom_point(aes(color= length_Outlier))


growth_mysis_outlier_length_mass_df<- growth_mysis_outlier_df

growth_mysis_outlier_length_mass_df <- growth_mysis_outlier_df

#factors have to be converted to strings first, or the factor level will transform as numeric
growth_mysis_outlier_length_mass_df$Mass_Outlier <- as.numeric(as.character(growth_mysis_outlier_length_mass_df$Mass_Outlier))
growth_mysis_outlier_length_mass_df$length_Outlier <- as.numeric(as.character(growth_mysis_outlier_length_mass_df$length_Outlier))



#create a sum of both length and mass outliers to see which observations are most impacted
growth_mysis_outlier_length_mass_df <-  growth_mysis_outlier_length_mass_df %>%
 mutate(Total_Outliers = select(., Mass_Outlier:length_Outlier) %>% rowSums(na.rm =TRUE))

#refactor the total to get discrete values for ploting

growth_mysis_outlier_length_mass_df$Total_Outlier <-factor(growth_mysis_outlier_length_mass_df$Total_Outlier, 
                                 levels = c("8","7","6","5","4","3","2","1","0"))

ggplot(growth_mysis_outlier_length_mass_df, aes(y=Mass_mg, x=Length_mm, color= Total_Outlier ))+geom_point()+scale_color_brewer(palette="Set1")


#create a numeric version of the total outlier for other graphs
growth_mysis_nofactor_outlier_df <- growth_mysis_outlier_length_mass_df

growth_mysis_nofactor_outlier_df$Total_Outlier <- as.numeric(as.character(growth_mysis_nofactor_outlier_df$Total_Outlier))



#What were the outliers with just one method, and which method more likely identified them

df_outliers_one_method <- growth_mysis_nofactor_outlier_df %>%
  filter(Total_Outlier==1)


#which method gives us the 1's in total outliers for both length and mass


#percentile more sensitive for mass
df_mysis_mass_one_method<-mysis_mass_outlier_method_df %>%
  filter(Sample_ID %in% df_outliers_one_method$Sample_ID)

#boxplot significantly provides more sensitivity to outliers than any other method
#for length
df_mysis_length_one_method<-mysis_length_outlier_method_df %>%
  filter(Sample_ID %in% df_outliers_one_method$Sample_ID)

#Plotting only te outlines that received 1 method for both length and mass combined
ggplot(growth_mysis_nofactor_outlier_df, aes(x=Length_mm,y=Mass_mg, color=Total_Outlier==1)) + 
         geom_point()+scale_color_brewer(palette="Set1")

#plotting outliers that received one method of detection for mass
ggplot(growth_mysis_nofactor_outlier_df, aes(y=Mass_mg,x=Age_Category)) + 
         geom_boxplot()+scale_color_brewer(palette="Set1") + 
  geom_jitter(data=. %>% filter(Sample_ID %in% df_mysis_mass_one_method$Sample_ID),color="red")                                                                 
#plotting outliers that received one method of detection for length

ggplot(growth_mysis_nofactor_outlier_df, aes(y=Length_mm,x=Age_Category)) + 
         geom_boxplot()+scale_color_brewer(palette="Set1") + 
  geom_point(data=. %>% filter(Sample_ID %in% df_mysis_length_one_method$Sample_ID),color="red")                                                                 

```


## Linear Model
Based on our outlier plots, we can be pretty certain a linear model is not appropriate
for our models. However,we will use the Residual plot to help us understand. Using these
plots its pretty clear a polynomial model is more appropriate. 


```{r Residuals}
y <- df_growth$Mass_mg
x <- df_growth$Length_mm

mod <- lm(y~x)

#Plot the residuals for a linear model. 
resid_panel(mod, plots='resid')


#Log transform both Mass and Length to compare a log transformed model against
#the original model
df_growth$Mass_log <- log(df_growth$Mass_mg)
df_growth$Length_log <- log(df_growth$Length_mm)
y2 <- df_growth$Mass_log
x2 <- df_growth$Length_log

mod_log <- lm(y2~x2)

#Compare the linear model to a log transformed model 
resid_compare(models=list(mod,
                          mod_log),
              plots= c("resid", "qq"),
              smoother = TRUE,
              qqbands = TRUE,
              title.opt = FALSE)

#This log tranformed residuals indicates that this  is a power function. 

#The plot shows us a linear model is not appropriate, so we will use a 2nd order
#polynomial 
#Growth Curves of Gemma and Mysis Mass vs Length

#SE represents the confidence interval

ggplot(df_growth, aes(x = Length_mm, y = Mass_mg, color = Feed_Group))+geom_point()+
  geom_smooth(method='lm',formula = y~poly(x,2,raw=TRUE),se=FALSE)


ggplot(df_growth, aes(x = Length_log, y = Mass_log, color = Feed_Group))+geom_point()+
  geom_smooth()

#Spearman Correlation, which does not require normality
df_growth_mysis <- df_growth %>%
  filter(.,Feed_Group=="Mysis")  
  cor(df_growth_mysis$Length_mm,df_growth_mysis$Mass_mg, method="spearman")

df_growth_gemma <- df_growth %>%
  filter(.,Feed_Group=="Gemma")  
  cor(df_growth_gemma$Length_mm,df_growth_gemma$Mass_mg, method="spearman")

#Visual representation of pearson correlation  
ggscatter(df_growth_mysis, x='Length_log', y='Mass_log', add = "reg.line", conf.int=TRUE, 
          cor.coef = TRUE, cor.method = "spearman", xlab = "Length (mm)", ylab = "Mass (mg)",
          title = "Mysis: Length Mass Log Relationship")


ggscatter(df_growth_gemma, x='Length_log', y='Mass_log', add = "reg.line", conf.int=TRUE, 
          cor.coef = TRUE, cor.method = "spearman", xlab = "Length (mm)", ylab = "Mass (mg)",
          title = "Gemma: Length Mass Log Relationship")


#Create linear model.
  
  
mysis_linear_model <- lm(Mass_log~Length_log,data=df_growth_mysis)
gemma_linear_model <- lm(Mass_log~Length_log,data=df_growth_gemma) 


plot(mysis_linear_model)





#model using one dataset for summary comparison
model <- lm(Mass_log~Length_log*Feed_Group, df_growth)

summary(model)  


ggplot(df_growth, aes(x=Length_log, y=Mass_log,group=Feed_Group))+geom_point(aes(color=Feed_Group))+
  geom_abline(intercept=)

#since we know based on qq plots and shapiro test, our set isn't normal, we will transform teh data via log transformation
#Do the transformed values pass the shapiro test?
qqnorm()
shapiro.test(resid(gemma_linear_model))



#Using ANOVA to compare 

```

## Exploritory Data Analysis for Sex Sort and Survival

The next two datasets are a bit more concise and we won't be doing as deep a dive 
into the outliers unless necessary. We are looking if there is any significant difference in either
sexing or survival from the two groups.

```{r Sex Sort Significance}
df_sex_sort
  
#Summarize the two groups Gemma & Mysis into total female, male, and unknown
#create a total column for each group
# turn sum into percentage for easier comparison between groups
df_sex_summary <-  df_sex_sort %>%
  group_by(Group) %>%
  summarise(female=sum(Female),male=sum(Male),unknown=sum(Unknown)) %>%
   mutate(Total = select(., female:unknown) %>% rowSums(na.rm =TRUE)) %>%
   mutate(female = round(female/Total,2),male = round(male/Total,2),unknown =
            round(unknown/Total,2))

#From a first glance there is hardly any difference beteween the two groups in terms
#of sex, but we will run some Significance testing to make sure. An ANOVA is appropriate
#in these situations

#Summary Stats: Mean and sd
df_sex_sort %>%
  group_by(Group) %>%
  get_summary_stats(Female,Male,Unknown, type = "mean_sd")

#ANOVA
df_sex_sort %>%
  anova_test(Female ~ Group)

df_sex_sort %>%
  anova_test(Male ~ Group)

df_sex_sort %>%
  anova_test(Unknown ~ Group)


t.test(df_sex_sort$Female~df_sex_sort$Group)
t.test(df_sex_sort$Male~df_sex_sort$Group)
t.test(df_sex_sort$Unknown~df_sex_sort$Group)

#Not seeing any significant differences using ANOVA or Wlech Two Sample t-test,
#which confirms what we saw in the percentage comparison earlier
```
This second is a bit trickier. Rather than having one time data point to test
We have taken survival from many different time points. First we will do some visualization
Next, We can take the overall reduction in survival, to see which group had higher survivors
Then we can see if there was any significant timeperiods.
```{r Survival Significance}
#Summarize data by feedgroup and date, the sum each group date, then plot
df_survival %>%
  group_by(Feed_Group,Date) %>%
    summarise(Census=sum(Census)) %>%
  ggplot(.,aes(x=Date,y=Census,color=Feed_Group)) +geom_line()

#Summarize the data like above using average
df_survival %>%
  group_by(Feed_Group,Date) %>%
    summarise(Census=mean(Census)) %>%
  ggplot(.,aes(x=Date,y=Census,color=Feed_Group)) +geom_line()

#individual tank survival grouped by feed type
ggplot(df_survival, aes(x=Date, y=Census, group = Tank, color = Feed_Group))+geom_line()+geom_point()

#create a df with just the differences in tank over the time period
df_survival_summary_wide<-df_survival %>%
  group_by(Date) %>%
  filter(Date == '2020-10-15'|Date=='2021-07-06') %>%
  pivot_wider(names_from = Tank, values_from = Census,values_fill = 0)


#individual tank survival grouped by feed type
ggplot(df_survival, aes(x=Date, y=Census, group = Tank, color = Feed_Group))+geom_point()+geom_smooth()



#We will look to see if the regression lines of each  group is statistically 
#different using ANCOVA. Feed_Group is out group variable, census is dependent,
# and Date is our independent variable

mod1 <- aov(Census~Date*Feed_Group, data=df_survival)
summary(mod1)

#The summary of these results show a significant effect of Census and Date, but
#no significant interaction. Now we test for significant differences in the slope

mod2 <- aov(Census~Date+Feed_Group, data=df_survival)
summary(mod2)

#This result shows that Feed_group as a significant impact on the dependent 
#variable, which we interpret as a significant difference in intercepts.

#Now ANOVA

anova(mod1,mod2)

#This ANOVA comparison shows us  that there is no significant result of removing
#the interaction between the two graphs. 




#Convert POSIXct format to numeric for regression model
df_survival$Date.numeric <-as.numeric(df_survival$Date)/(24*60*60)
  
#subset survival groups

mysis_survival <-  df_survival %>%
    filter(Feed_Group == 'Mysis')
gemma_survival<-  df_survival %>%
  filter(Feed_Group == 'Gemma')
#Build linear regression models for both survival rates


linear_Mod_Mysis <- mysis_survival %>%
  lm(Census~Date.numeric, data=.)

linear_Mod_Gemma <- gemma_survival %>%
  lm(Census~Date.numeric, data=.)

#summary for linear modals. The shift from POSIXct fixed the issues I was having
summary(linear_Mod_Mysis)
summary(linear_Mod_Gemma)

#Summary indicates that Mysis and Gemma have similar intercepts 244.68,538.6,but gemma is higher which 
#makes sense given their starting numbers were the same, but their slopes are different, eventually
#Gemma will trace back at a higher y-intercept than Mysis. 


plot(Census~Date.numeric, data = df_survival, type = 'n')+
  points(mysis_survival$Date.numeric,mysis_survival$Census,pch=20)+
  points(gemma_survival$Date.numeric,gemma_survival$Census,pch=1)+
  abline(linear_Mod_Mysis,lty=1)+
  abline(linear_Mod_Gemma,lty=2)+
  legend("bottomleft", c("Mysis","Gemma"), lty=c(1,2), pch=c(20,1))

ggscatter(df_survival, x="Date", y="Census", color= "Feed_Group", add="reg.line")+
  stat_regline_equation(aes(label = paste(..eq.label..,..rr.label..,sep="~~~~"), color=Feed_Group))


#we can see that the models show a signficant difference between the two, with 
#mysis having a smaller intercept, showing gemma has a higher  survival rate
#

#Looking at this a different way, we truely only care that there is a difference at 
#the end of the high-aggression period. While it is interesting to see, where and
#when there may be different trends or how one trend impacts the other, this is something
#that requires a lot more study. 


#We are going to test the normality of residuals. 
model.metrics <- augment(mod2) %>%
subset(.,select=c(-.hat,-.sigma,-.fitted))

#shapiro wilk test if not significant (our case) tells us we can assume normality
shapiro_test(model.metrics$.resid)

#now we figure equality of variance of the residuals using Leven's test for ANCOVA
model.metrics %>% levene_test(.resid ~ Feed_Group) #this is also not significant

#look at outliers for the dataset

#Looking for standardized residuals greater than 3 in absolute value. Because we don't 
#see any we can assume no outliers. 
model.metrics %>%
  filter(abs(.std.resid) > 3) %>%
  as.data.frame()

res.aov <- df_survival %>% anova_test(Census~Date+Feed_Group) 

get_anova_table(res.aov)

library(emmeans)

#pairwise comparisons
pwc<-df_survival %>%
  emmeans_test(
    Census~Feed_Group, covariate=Date,
    p.adjust.method = "bonferroni")
  get_emmeans(pwc)
  
#Line_Plot
  
  lp <- ggline(
  get_emmeans(pwc), x = "Date", y = "emmean", 
  color = "Feed_Group", palette = "jco"
  ) +
  geom_errorbar(
    aes(ymin = conf.low, ymax = conf.high, color = Feed_Group), 
    width = 0.1
    )

  print(lp)  

#ANOVA on final set
ANOVA_df <- df_survival %>%
  filter(.,Date=='2021-07-06')

res2.aov <- ANOVA_df %>% anova_test(Census~Feed_Group) 

get_anova_table(res2.aov)  

#Compare the final set of data between groups using Welsh's T Test
t.test(ANOVA_df$Census~ANOVA_df$Feed_Group)



```

